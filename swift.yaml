- text: varで定義されるのは
  choice:
    - 値を変えることができる変数
    - 値を変えることができない定数
    - 関数
    - プログラム
- text: letで定義されるのは
  choice:
    - 値を変えることができない定数
    - 値を変えることができる変数
    - 関数
    - プログラム
- text: 値を変えられる変数を定義するときに使うキーワードは
  choice:
    - var
    - let
    - func
    - return
- text: 関数から値を返すために使うキーワードは
  choice:
    - return
    - func
    - var
    - if
- text: 整数を表す型は
  choice:
    - Int
    - int
    - x
    - integer
- text: 文字列を表す型は
  choice:
    - String
    - s
    - string
    - '[s]'
- text: オブジェクトを生成するには
  choice:
    - 型名(引数)
    - 型名[引数]
    - 型名{引数}
    - 型名 引数
- text: 仲間外れは
  choice:
    - var
    - Int
    - "[String]"
    - Bool
- text: 仲間外れは
  choice:
    - 1 + 1
    - 2.0 * 3.0
    - -4.0
    - 7.0
    - 1.1 + 1.8 * 2.0
- text: 仲間外れは
  choice:
    - var
    - let
    - func
    - return
    - tensuu
- text: 複数の値をまとめるXXX。XXXとは
  choice:
    - タプル
    - 変数
    - 引数
    - 型
- text: 「Stringのリストのリスト」型になるのは
  choice:
    - "[[String]]"
    - String[[]]
    - String[][]
    - String([], [])
- text: 「Intのリストのリスト」型になるのは
  choice:
    - "[[3], [4, 8]]"
    - "[[10], [1, 11], [0.1]]"
    - "[0, 1, 0, 1]"
    - "[0, 1], [0, 1]"
- text: "Intのリスト(例えばx)にIntを追加する append(_ newElement: Int)の正しい使い方の例は"
  choice:
    - "x.append(3)"
    - "x.append(_ newElement: 3)"
    - "x.append(newElement: 3)"
    - "x.append(_ newElement: Int 3)"
- text: "自分で定義した関数 f1(arg: Int)の正しい実行例は"
  choice:
    - "f1(arg: 2)"
    - "f1(_ arg: 2)"
    - "f1(2)"
    - "f1(arg: Int)"
- text: "自分で定義した関数 f1(of arg: Int)の正しい実行例は"
  choice:
    - "f1(of: 2)"
    - "f1(arg: 2)"
    - "f1(of arg: 2)"
    - "f1(of 2)"
    - "f1(of arg 2)"
    - "f1(2)"
- text: "f1(by: true)がエラーでないとする。正しい理解は"
  choice:
    - byというのが外部引数名か内部引数名か、どちらなのかはこれだけではわからない
    - 引数は2個必要である
    - trueのところをfalseに変えると構文エラーになる
    - byはtrue型である
- text: "自分で定義した関数 f(x arg: String)の正しい使い方の例は"
  choice:
    - "f(x: \"東京\")"
    - "f(x \"東京\")"
    - "f(\"東京\")"
    - "f(x arg: \"東京\")"
    - "f(arg: \"東京\")"
- text: "自分で定義した関数 f(arg: String)の正しい使い方の例は"
  choice:
    - "f(arg: \"東京\")"
    - "f(arg \"東京\")"
    - "f(arg String: \"東京\")"
    - "f(\"東京\")"
    - "f()"
    - "f(String)"
- text: "自分で定義した関数 f(arg: [Bool])の正しい実行例は"
  choice:
    - "f(arg: Bool)"
    - "f(arg: [Bool])"
    - "f(arg: true)"
    - "f(arg: [])"
    - "f([false, true])"
- text: "func f(A B: C) においてAは"
  choice:
    - 外部引数名に対応する
    - 外部変数名に対応する
    - 内部引数名に対応する
    - 型名に対応する
- text: "関数定義 func f(A B: C) においてAは"
  choice:
    - 引数ラベル
    - 関数ラベル
    - 変数ラベル
    - 型ラベル
- text: 関数を定義するときのキーワードは
  choice:
    - func
    - struct
    - let
    - return
- text: "関数定義 func f(A B: C) においてBは"
  choice:
    - 内部引数名
    - 外部引数名
    - 外部変数名
    - 関数名
- text: "関数定義 func f(A B: C) においてCは"
  choice:
    - 型名
    - 内部引数名
    - 引数ラベル
    - 外部変数名
- text: Int型の変数xとDouble型の変数yをエラーなく足すには
  choice:
    - Double(x) + y
    - x + Double(y)
    - x + y
    - Double(x + y)
- text: print("40" + "8")の結果は
  choice:
    - 408が出力される
    - 48が出力される
    - エラーなので実行できない
    - 40が出力され、（次の行に）8が出力される
- text: "変数xが[9, 8, 25]だとする。x.remove(at: 1)の実行結果は"
  choice:
    - xは[9, 25]になる
    - xは[9, 0, 25]になる
    - xは[1, 8, 25]になる    
    - xは[8, 25]になる
    - xは[9, 1, 25]になる
- text: var x = 88　だとするとxの型は
  choice:
    - Int型
    - Double型
    - Int型かDouble型か決められないのでエラー
    - Int型かDouble型かまだ決まってないがエラーではない
- text: var x = 165.0 とする。これは身長（センチ）を表す変数である。正しく出力するのは
  choice:
    - print("身長は \(x / 100.0) メートルです")
    - print("身長は \(x * 100.0) メートルです")
    - print("身長は \(x) メートルです")
    - print("身長は \(x / 100) メートルです")
    - print("身長は \(x * 100) メートルです")
- text: エラーにならないのは
  choice:
    - "var 日本語: Int"
    - "var \"xy3\": Int"
    - "var 3xy: Int"
    - "var x3y[]: Int"
- text: list[4] と同じ型になるものは（listの詳細に関する説明はない）
  choice:
    - "list[3]"
    - "list[]"
    - "list"
    - "[list]"
- text: 式展開で文字列(String)中に値を埋め込むのに使うのは
  choice:
    - バックスラッシュ(\\)
    - スラッシュ(/)
    - ドル記号($)
    - バッククオート(')
- text: 20 % 3 の計算結果は
  choice:
    - 2
    - 6
    - 7
    - 6.6666...
    - エラーなのでそもそも計算できない
- text: リスト型の変数xから先頭要素を関数removeFirst()で除きたい。正しいのは
  choice:
    - x.removeFirst()
    - removeFirst(x)
    - x.removeFirst
    - removeFirst(x[0])
- text: エラーにならないのは
  choice:
    - "@State var x: Int"
    - "?State var x: Int"
    - "State@ var x: Int"
    - "State var x: Int"
    - "State(var x: Int)"
- text: 関数を定義するときに使うキーワードは
  choice:
    - func
    - function
    - f
    - fn
- text: if A { B } else { C }と同じなのは
  choice:
    - "A ? B : C"
    - "A : B ? C"
    - "A"
    - "if A else { C } { B }"
- text: 変数xを、Intのリスト型で、最初は中身は空として定義するのは
  choice:
    - "var x: [Int] = []"
    - "var x: Int = []"
    - "var x = []"
    - "var x = 0"
    - "var x: [Int]"
- text: リテラルになっているのは
  choice:
    - 10
    - x
    - 2 + 8
    - 0 * x
- text: リテラルになっているのは
  choice:
    - "ab"
    - ab
    - a.b
    - a * b
- text: リテラルになっているのは
  choice:
    - true
    - let
    - return
    - View
- text: "x = a.b(c: 3) がエラーでないとする。正しいものは"
  choice:
    - bはメソッド
    - aは関数
    - bは関数
    - aはメソッド
- text: 以下のプログラムがエラーでないとする。もっとも正しいものは
  code: |
    x = y
    x = a.b(c: 3)

  choice:
    - xはvarを使って定義されている
    - xはInt型である
    - aはfuncを使って定義されている
    - xもaもInt型である
- text: 以下のプログラムでXXXとは
  code: |
    func f(a: Int, b: Int) XXX {
      return a < b
    }

  choice:
    - "-> Bool"
    - "=> Bool"
    - ": Bool"
    - "Bool"
- text: 以下のプログラムでXXXとは
  code: |
    func f(a: Int, b: Int) -> [Int] {
      return XXX
    }

  choice:
    - "[a]"
    - "a + b"
    - "a < b"
    - "[Int]"
- text: 以下のエラーがないプログラムでXXXは
  code: |
    func f(a: Int, b: Int) -> String {
      return XXX
    }

  choice:
    - "\"String\""
    - "[a]"
    - "a + b"
    - "a < b"
- text: 以下のエラーがないプログラムでXXXは
  code: |
    func f(a: Int) -> String {
      return XXX
    }

  choice:
    - String(a)
    - String
    - Int -> String
    - String[]
- text: 以下の関数fを使う（呼び出す）ときに指定すべき引数の数は
  code: |
    func f(a: Int, b: Int) {
      ...
    }

  choice:
    - 2個
    - 4個
    - 何個でもよい
    - 0個
- text: 以下の関数fを使うときに指定すべき引数の数は
  code: |
    func f(_ b: Int) {
      ...
    }

  choice:
    - 1個
    - 2個
    - 3個
    - 4個
- text: 以下の関数fを使うときに指定すべき引数の数は
  code: |
    func f(first a: Int, second b: Int) {
      ...
    }

  choice:
    - 2個
    - 4個
    - 6個
    - 8個
- text: 関数呼び出し f(3) における引数の数は
  choice:
    - 1個
    - 0個
    - 2個
    - 3個
- text: "関数呼び出し f(true, true, true) における引数の数は"
  choice:
    - 3個
    - 1個
    - 2個
    - 0個
- text: "関数呼び出し f(from: 1, to: 9) における引数の数は"
  choice:
    - 2個
    - 4個
    - 9個
    - 1から9個
- text: "関数呼び出し f(at: 1) における引数の数は"
  choice:
    - 1個
    - 2個
    - 3個
    - 0個
- text: "x = a.b(c: 3) がエラーでないとする。もっともありえるのは"
  choice:
    - "x = a.b(c: 3 + 1) もエラーにならない"
    - "a = x.b(c: 3) もエラーにならない"
    - "x = a.b(3) もエラーにならない"
    - "x = a.b(c: 3.0) もエラーにならない"
- text: "x = a.b(c: 3) がエラーでないとする。正しいものは"
  choice:
    - 3は引数（パラメータ）
    - cは引数（パラメータ）
    - bは引数（パラメータ）
    - aは引数（パラメータ）
- text: 型を自動認識するXXX。XXXとは
  choice:
    - 型推論
    - 型認識
    - 型計算
    - 計算型
- text: 以下のプログラムでa, b, cの点数の合計を計算するのは
  code: |
    struct Person {
       var name: String
       var 点数: Int
       var email: String
    }
    var a: Person = Person(XXX)
    var b: Person = Person(YYY)
    var c: Person = Person(ZZZ)

  choice:
    - a.点数 + b.点数 + c.点数
    - a + b + c
    - 点数 + 点数 + 点数
    - Person(XXX) + Person(YYY) + Person(ZZZ)
- text: 以下のプログラムでXXXの正しい例は
  code: |
    struct Person {
       var name: String
       var 点数: Int
       var email: String
    }
    var a: Person = XXX

  choice:
    - "Person(name: \"namae\", 点数: 90, email: \"aaa@cccc.dd\")"
    - "namae"
    - "Person(\"namae\", 80, \"aaa@cccc.dd\")"
    - "struct Person { var name: String var 点数: Int var email: String }"
- text: "\"3.2\"の型は"
  choice:
    - String
    - Int
    - Double
    - "\"Double\""
- text: "\"10\"の型は"
  choice:
    - String
    - Int
    - Double
    - "\"10\""
- text: 3 * 8 の型は
  choice:
    - Int
    - 24
    - Double
    - String
- text: 3 < 8 の型は
  choice:
    - Bool
    - Int
    - Int < Int
    - Bool < Bool
